@page "/"
@using Microsoft.AspNetCore.Components.Web
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@inject SpeechRecognitionService SpeechService
@inject SummarizationService SummarizationService
@inject IJSRuntime JS

<PageTitle>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ éŸ³å£°æ–‡å­—èµ·ã“ã—</PageTitle>

<div class="container-fluid px-4 py-3">
    <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div>
            <h2 class="mb-1 fw-bold">ğŸ¤ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ éŸ³å£°æ–‡å­—èµ·ã“ã—</h2>
            <p class="text-muted small mb-0">
                ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ãƒ‡ãƒ¢ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã§ã™ã€‚éŸ³å£°èªè­˜ãŠã‚ˆã³è©±è€…åˆ†é›¢ã®çµæœã«ã¯èª¤ã‚ŠãŒå«ã¾ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
            </p>
        </div>
        <div class="d-flex align-items-center gap-3">
            @if (isRecording)
            {
                <span class="badge bg-danger px-3 py-2">
                    <span class="spinner-grow spinner-grow-sm me-2"></span>
                    éŒ²éŸ³ä¸­
                </span>
            }
            @if (isProcessing)
            {
                <span class="badge bg-warning text-dark px-3 py-2">
                    <span class="spinner-border spinner-border-sm me-2"></span>
                    è©±è€…åˆ†é›¢å‡¦ç†ä¸­
                </span>
            }
            <button class="btn @(isRecording ? "btn-danger" : "btn-primary") d-flex align-items-center gap-2" 
                    @onclick="ToggleRecording"
                    disabled="@isProcessing"
                    style="min-width: 150px;">
                @if (isRecording)
                {
                    <span>â¹</span>
                    <span>åœæ­¢</span>
                }
                else
                {
                    <span>ğŸ¤</span>
                    <span>ãƒã‚¤ã‚¯ON</span>
                }
            </button>
        </div>
    </div>

    <!-- é€Ÿè¨˜è€…ãƒ¡ãƒ¢å…¥åŠ›ï¼ˆéŒ²éŸ³ä¸­ã®ã¿è¡¨ç¤ºï¼‰ -->
    @if (isRecording)
    {
        <div class="card border-warning mb-3 shadow-sm">
            <div class="card-body py-2">
                <div class="d-flex align-items-center gap-2">
                    <span class="text-warning fw-bold">ğŸ“</span>
                    <input type="text" class="form-control form-control-sm border-0" @bind="currentNote" @bind:event="oninput"
                           @onkeydown="HandleNoteKeyDown"
                           placeholder="é€Ÿè¨˜ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦Enterã§è¿½åŠ ..." />
                    <button class="btn btn-sm btn-warning" @onclick="AddNote" disabled="@(string.IsNullOrWhiteSpace(currentNote))">
                        è¿½åŠ 
                    </button>
                </div>
            </div>
        </div>
    }

    <div class="row">
        <div class="col-12">
            <div class="row g-3 mb-3">
                <!-- å·¦å´: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã— -->
                <div class="col-md-6">
                    <div class="card shadow-sm h-100">
                        <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center py-2">
                            <div>
                                <h6 class="mb-0">âš¡ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—</h6>
                                <small class="opacity-75">è©±è€…åˆ†é›¢ãªã—ãƒ»é«˜é€Ÿè¡¨ç¤º</small>
                            </div>
                            <button class="btn btn-light btn-sm" 
                                    @onclick="CopyRealtimeTranscription"
                                    disabled="@(realtimeTranscriptions.Count == 0)">
                                ğŸ“‹ ã‚³ãƒ”ãƒ¼
                            </button>
                        </div>
                        <div class="card-body" style="height: 500px; overflow-y: auto;" id="realtimeArea">
                            @if (realtimeTranscriptions.Count == 0)
                            {
                                <p class="text-muted">ãƒã‚¤ã‚¯ã‚’ONã«ã—ã¦è©±ã—å§‹ã‚ã¦ãã ã•ã„...</p>
                            }
                            else
                            {
                                @foreach (var item in realtimeTranscriptions.AsEnumerable().Reverse())
                                {
                                    @if (item.IsNote)
                                    {
                                        <div class="mb-2 p-2 border border-warning bg-warning bg-opacity-10 rounded">
                                            <div class="d-flex justify-content-between align-items-start mb-1">
                                                <div>
                                                    <strong class="badge bg-warning text-dark">ğŸ“ é€Ÿè¨˜ãƒ¡ãƒ¢</strong>
                                                    <small class="text-muted ms-2">
                                                        @item.Timestamp.ToString("HH:mm:ss")
                                                    </small>
                                                </div>
                                            </div>
                                            <div class="fst-italic">@item.Text</div>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="mb-2 p-2 @(item.IsFinalized ? "bg-light" : "bg-warning bg-opacity-25") rounded">
                                            <div class="d-flex justify-content-between align-items-start mb-1">
                                                <div>
                                                    @if (ShowRealtimeSpeaker && item.IsFinalized && !string.IsNullOrEmpty(item.SpeakerId) && item.SpeakerId != "Unknown")
                                                    {
                                                        <strong class="@GetSpeakerColor(item.SpeakerId) me-2">
                                                            @GetSpeakerName(item.SpeakerId)
                                                        </strong>
                                                    }
                                                    <small class="text-muted">
                                                        @item.Timestamp.ToString("HH:mm:ss")
                                                        @if (!item.IsFinalized)
                                                        {
                                                            <span class="ms-2">èªè­˜ä¸­...</span>
                                                        }
                                                    </small>
                                                </div>
                                            </div>
                                            <div>@item.Text</div>
                                        </div>
                                    }
                                }
                            }
                        </div>
                    </div>
                </div>

                <!-- å³å´: è©±è€…åˆ†é›¢çµæœ -->
                <div class="col-md-6">
                    <div class="card shadow-sm">
                        <div class="card-header bg-success text-white d-flex justify-content-between align-items-center py-2">
                            <div>
                                <h6 class="mb-0">ğŸ¯ è©±è€…åˆ†é›¢çµæœ</h6>
                                <small class="opacity-75">éŒ²éŸ³åœæ­¢å¾Œã«è‡ªå‹•å‡¦ç†</small>
                            </div>
                            <button class="btn btn-light btn-sm" 
                                    @onclick="CopyDiarizedTranscription"
                                    disabled="@(diarizedTranscriptions.Count == 0)">
                                ğŸ“‹ ã‚³ãƒ”ãƒ¼
                            </button>
                        </div>
                        <div class="card-body" style="height: 500px; overflow-y: auto;" id="diarizedArea">
                            @if (diarizedTranscriptions.Count == 0)
                            {
                                <p class="text-muted text-center mt-5">åœæ­¢ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨è©±è€…åˆ†é›¢çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>
                            }
                            else
                            {
                                @foreach (var item in diarizedTranscriptions.AsEnumerable().Reverse())
                                {
                                    <div class="mb-2 p-2 rounded @GetDiarizedSpeakerClass(item.SpeakerId)">
                                        <div class="d-flex justify-content-between align-items-start mb-1">
                                            <strong class="@GetDiarizedSpeakerColor(item.SpeakerId)">
                                                @GetDiarizedSpeakerName(item.SpeakerId)
                                            </strong>
                                            <small class="text-muted">@item.Timestamp.ToString("HH:mm:ss")</small>
                                        </div>
                                        <div>@item.Text</div>
                                    </div>
                                }
                            }
                        </div>
                    </div>
                </div>
            </div>

            <!-- è¦ç´„ç”Ÿæˆã‚¨ãƒªã‚¢ -->
            <div class="row mt-3">
                <div class="col-12">
                    <div class="card shadow-sm">
                        <div class="card-header bg-info text-white d-flex justify-content-between align-items-center py-2">
                            <div>
                                <h6 class="mb-0">ğŸ“ AIè¦ç´„</h6>
                                <small class="opacity-75">æ–‡å­—èµ·ã“ã—çµæœã‚’åˆ†æãƒ»è¦ç´„</small>
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-light btn-sm" 
                                        @onclick="CopySummary"
                                        disabled="@(string.IsNullOrEmpty(summaryText))">
                                    ğŸ“‹ ã‚³ãƒ”ãƒ¼
                                </button>
                                <button class="btn btn-light btn-sm" 
                                        @onclick="GenerateSummary"
                                        disabled="@(diarizedTranscriptions.Count == 0 || isSummarizing)">
                                    @if (isSummarizing)
                                    {
                                        <span class="spinner-border spinner-border-sm me-2"></span>
                                        <span>ç”Ÿæˆä¸­...</span>
                                    }
                                    else
                                    {
                                        <span>âœ¨ è¦ç´„ç”Ÿæˆ</span>
                                    }
                                </button>
                            </div>
                        </div>
                        <div class="card-body" style="min-height: 200px; max-height: 600px; overflow-y: auto;">
                            @if (string.IsNullOrEmpty(summaryText))
                            {
                                <p class="text-muted text-center mt-5">è©±è€…åˆ†é›¢å®Œäº†å¾Œã€ã€Œè¦ç´„ç”Ÿæˆã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„</p>
                            }
                            else if (summaryError != null)
                            {
                                <div class="alert alert-danger mb-0" role="alert">
                                    <strong>ã‚¨ãƒ©ãƒ¼:</strong> @summaryError
                                </div>
                            }
                            else
                            {
                                <div class="summary-content">@((MarkupString)summaryText.Replace("\n", "<br />"))</div>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—ã§è©±è€…ã‚’è¡¨ç¤ºã™ã‚‹ã‹ã©ã†ã‹ï¼ˆfalseã§éè¡¨ç¤ºï¼‰
    private const bool ShowRealtimeSpeaker = false;
    
    private bool isRecording = false;
    private bool isProcessing = false;
    private bool isSummarizing = false;
    private List<TranscriptionItem> realtimeTranscriptions = new();
    private List<TranscriptionItem> diarizedTranscriptions = new();
    private List<TranscriptionItem> transcriptions = new(); // äº’æ›æ€§ã®ãŸã‚æ®‹ã™
    private DotNetObjectReference<Home>? objRef;
    private Dictionary<string, TranscriptionItem> ongoingTranscriptions = new();
    private string? currentRecordingPath;
    private Dictionary<string, int> speakerMapping = new(); // Azure ID â†’ UIç•ªå·ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç”¨ï¼‰
    private Dictionary<string, int> diarizedSpeakerMapping = new(); // Azure ID â†’ UIç•ªå·ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆè©±è€…åˆ†é›¢ç”¨ï¼‰
    private int nextSpeakerNumber = 1; // æ¬¡ã«å‰²ã‚Šå½“ã¦ã‚‹è©±è€…ç•ªå·
    private string currentNote = string.Empty; // ç¾åœ¨å…¥åŠ›ä¸­ã®ãƒ¡ãƒ¢
    private string summaryText = string.Empty;
    private string? summaryError = null;

    protected override void OnInitialized()
    {
        SpeechService.OnTranscriptionReceived += HandleTranscription;
        SpeechService.OnTranscribing += HandleTranscribing;
        
        // AIè¦ç´„ã‚µãƒ¼ãƒ“ã‚¹ã®åˆæœŸåŒ–ã‚’é–‹å§‹ï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œï¼‰
        _ = Task.Run(async () => 
        {
            try
            {
                await SummarizationService.SummarizeTranscriptionAsync("", "", null);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"AIåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼ï¼ˆç„¡è¦–å¯èƒ½ï¼‰: {ex.Message}");
            }
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
        }
    }

    private async Task ToggleRecording()
    {
        isRecording = !isRecording;
        
        if (isRecording)
        {
            realtimeTranscriptions.Clear();
            diarizedTranscriptions.Clear();
            speakerMapping.Clear();
            nextSpeakerNumber = 1;
            currentRecordingPath = await JS.InvokeAsync<string>("startRecording", objRef);
            await SpeechService.StartRecognitionAsync();
        }
        else
        {
            await JS.InvokeVoidAsync("stopRecording");
            await SpeechService.StopRecognitionAsync();
            
            // éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è©±è€…åˆ†é›¢ã‚’å®Ÿè¡Œ
            if (!string.IsNullOrEmpty(currentRecordingPath))
            {
                await ProcessDiarization(currentRecordingPath);
            }
        }
        
        StateHasChanged();
    }
    
    private async Task ProcessDiarization(string recordingPath)
    {
        isProcessing = true;
        StateHasChanged();
        
        try
        {
            Console.WriteLine($"Starting diarization for: {recordingPath}");
            
            // WebMãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’å–å¾—ï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã‚’ç¢ºèªï¼‰
            var downloadsPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "Downloads");
            var webmFile = Path.Combine(downloadsPath, recordingPath);
            
            if (!File.Exists(webmFile))
            {
                Console.WriteLine($"Recording file not found: {webmFile}");
                return;
            }
            
            // Azure Speeché«˜é€Ÿæ–‡å­—èµ·ã“ã—APIã§è©±è€…åˆ†é›¢ï¼ˆWebMç›´æ¥ã‚µãƒãƒ¼ãƒˆï¼‰
            var results = await SpeechService.ProcessAudioFileWithDiarizationAsync(webmFile);
            
            // è©±è€…åˆ†é›¢ç”¨ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            diarizedSpeakerMapping.Clear();
            int diarizedNextSpeakerNumber = 1;
            
            // çµæœã‚’è¡¨ç¤ºç”¨ã«å¤‰æ›
            diarizedTranscriptions.Clear();
            var baseTime = DateTime.Now;
            
            foreach (var (text, speakerId, offset) in results)
            {
                // è©±è€…åˆ†é›¢ç”¨ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½¿ç”¨
                if (!string.IsNullOrEmpty(speakerId) && speakerId != "Unknown" && !diarizedSpeakerMapping.ContainsKey(speakerId))
                {
                    diarizedSpeakerMapping[speakerId] = diarizedNextSpeakerNumber++;
                }
                
                diarizedTranscriptions.Add(new TranscriptionItem
                {
                    Text = text,
                    SpeakerId = speakerId,
                    Timestamp = baseTime.Add(offset)
                });
            }
            
            Console.WriteLine($"Diarization completed: {results.Count} segments");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Diarization error: {ex.Message}");
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task ReceiveAudioData(int[] audioData)
    {
        if (audioData != null && audioData.Length > 0)
        {
            var byteArray = new byte[audioData.Length];
            for (int i = 0; i < audioData.Length; i++)
            {
                byteArray[i] = (byte)audioData[i];
            }
            await SpeechService.ProcessAudioDataAsync(byteArray);
        }
    }

    private void HandleTranscribing(string text, string speakerId)
    {
        // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®é€”ä¸­çµŒéã‚’è¡¨ç¤ºï¼ˆè©±è€…æƒ…å ±ã¯ä½¿ã‚ãªã„ï¼‰
        // æœ€å¾Œã®æœªç¢ºå®šã‚¢ã‚¤ãƒ†ãƒ ï¼ˆãƒ¡ãƒ¢ä»¥å¤–ï¼‰ã‚’æ¢ã—ã¦æ›´æ–°
        if (realtimeTranscriptions.Count > 0)
        {
            // æœ€å¾Œã‹ã‚‰é †ã«æ¢ã—ã¦ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸæœªç¢ºå®šã®æ–‡å­—èµ·ã“ã—ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ›´æ–°
            for (int i = realtimeTranscriptions.Count - 1; i >= 0; i--)
            {
                var item = realtimeTranscriptions[i];
                if (!item.IsFinalized && !item.IsNote)
                {
                    // æ—¢å­˜ã®èªè­˜ä¸­ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä¸Šæ›¸ã
                    item.Text = text;
                    item.Timestamp = DateTime.Now;
                    InvokeAsync(StateHasChanged);
                    return;
                }
            }
        }
        
        // èªè­˜ä¸­ã®æ–°è¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
        realtimeTranscriptions.Add(new TranscriptionItem
        {
            Text = text,
            SpeakerId = "Unknown",
            Timestamp = DateTime.Now,
            IsFinalized = false
        });
        
        InvokeAsync(StateHasChanged);
    }

    private void HandleTranscription(string text, string speakerId)
    {
        // ç¢ºå®šã—ãŸçµæœã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«è¿½åŠ ï¼ˆè©±è€…æƒ…å ±ã‚‚åæ˜ ï¼‰
        if (realtimeTranscriptions.Count > 0)
        {
            // æœ€å¾Œã‹ã‚‰é †ã«æ¢ã—ã¦ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸæœªç¢ºå®šã®æ–‡å­—èµ·ã“ã—ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç¢ºå®š
            for (int i = realtimeTranscriptions.Count - 1; i >= 0; i--)
            {
                var item = realtimeTranscriptions[i];
                if (!item.IsFinalized && !item.IsNote)
                {
                    // æœ€å¾Œã®èªè­˜ä¸­ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç¢ºå®šï¼ˆè©±è€…IDã‚‚æ›´æ–°ï¼‰
                    item.Text = text;
                    item.SpeakerId = speakerId;
                    item.IsFinalized = true;
                    InvokeAsync(StateHasChanged);
                    return;
                }
            }
        }
        
        // è©²å½“ã™ã‚‹èªè­˜ä¸­ã‚¢ã‚¤ãƒ†ãƒ ãŒãªã„å ´åˆã¯æ–°è¦è¿½åŠ ï¼ˆé€šå¸¸ç™ºç”Ÿã—ãªã„ï¼‰
        realtimeTranscriptions.Add(new TranscriptionItem
        {
            Text = text,
            SpeakerId = "Unknown",
            Timestamp = DateTime.Now,
            IsFinalized = true
        });
        
        InvokeAsync(StateHasChanged);
    }

    private string GetSpeakerClass(string speakerId)
    {
        return speakerId switch
        {
            "Guest-1" => "bg-primary bg-opacity-10 border-start border-primary border-4",
            "Guest-2" => "bg-success bg-opacity-10 border-start border-success border-4",
            _ => "bg-secondary bg-opacity-10 border-start border-secondary border-4"
        };
    }

    private string GetSpeakerColor(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "badge bg-secondary";
        }
        
        // ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚ŒãŸç•ªå·ã«å¿œã˜ã¦è‰²ã‚’å¤‰ãˆã‚‹
        if (!speakerMapping.ContainsKey(speakerId))
        {
            speakerMapping[speakerId] = nextSpeakerNumber++;
        }
        
        return speakerMapping[speakerId] switch
        {
            1 => "badge bg-primary",
            2 => "badge bg-success",
            3 => "badge bg-info",
            4 => "badge bg-warning",
            5 => "badge bg-danger",
            _ => "badge bg-secondary"
        };
    }

    private async Task HandleNoteKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(currentNote))
        {
            // Enterã‚­ãƒ¼ã§ãƒ¡ãƒ¢è¿½åŠ 
            AddNote();
            await Task.CompletedTask;
        }
    }

    private void AddNote()
    {
        if (string.IsNullOrWhiteSpace(currentNote))
            return;
        
        // ãƒ¡ãƒ¢ã‚’å˜ç´”ã«è¿½åŠ ã™ã‚‹ã ã‘ã€‚èªè­˜ä¸­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯ä¸€åˆ‡è§¦ã‚Œãªã„ã€‚
        realtimeTranscriptions.Add(new TranscriptionItem
        {
            Text = currentNote.Trim(),
            Timestamp = DateTime.Now,
            IsNote = true,
            IsFinalized = true
        });
        
        currentNote = string.Empty;
        StateHasChanged();
    }

    private string GetSpeakerName(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "è­˜åˆ¥ä¸­...";
        }
        
        // Azure IDã‚’UIç”¨ã®é€£ç•ªã«ãƒãƒƒãƒ”ãƒ³ã‚°
        if (!speakerMapping.ContainsKey(speakerId))
        {
            speakerMapping[speakerId] = nextSpeakerNumber++;
        }
        
        return $"è©±è€…{speakerMapping[speakerId]}";
    }

    // è©±è€…åˆ†é›¢çµæœç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆç‹¬ç«‹ã—ãŸãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½¿ç”¨ï¼‰
    private string GetDiarizedSpeakerName(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "è­˜åˆ¥ä¸­...";
        }
        
        if (diarizedSpeakerMapping.ContainsKey(speakerId))
        {
            return $"è©±è€…{diarizedSpeakerMapping[speakerId]}";
        }
        
        return speakerId;
    }

    private string GetDiarizedSpeakerColor(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "badge bg-secondary";
        }
        
        if (diarizedSpeakerMapping.ContainsKey(speakerId))
        {
            return diarizedSpeakerMapping[speakerId] switch
            {
                1 => "badge bg-primary",
                2 => "badge bg-success",
                3 => "badge bg-info",
                4 => "badge bg-warning",
                5 => "badge bg-danger",
                _ => "badge bg-secondary"
            };
        }
        
        return "badge bg-secondary";
    }

    private string GetDiarizedSpeakerClass(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "bg-light";
        }
        
        if (diarizedSpeakerMapping.ContainsKey(speakerId))
        {
            return diarizedSpeakerMapping[speakerId] switch
            {
                1 => "bg-primary bg-opacity-10",
                2 => "bg-success bg-opacity-10",
                3 => "bg-info bg-opacity-10",
                4 => "bg-warning bg-opacity-10",
                5 => "bg-danger bg-opacity-10",
                _ => "bg-light"
            };
        }
        
        return "bg-light";
    }

    private async Task GenerateSummary()
    {
        isSummarizing = true;
        summaryError = null;
        summaryText = string.Empty;
        StateHasChanged();

        try
        {
            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
            var realtimeText = string.Join("\n", 
                realtimeTranscriptions
                    .OrderBy(t => t.Timestamp)
                    .Select(t => {
                        if (t.IsNote)
                        {
                            return $"[{t.Timestamp:HH:mm:ss}] ã€é€Ÿè¨˜ãƒ¡ãƒ¢ã€‘{t.Text}";
                        }
                        else
                        {
                            string speakerName = GetSpeakerName(t.SpeakerId);
                            return $"[{t.Timestamp:HH:mm:ss}] {speakerName}: {t.Text}";
                        }
                    }));

            // è©±è€…åˆ†é›¢çµæœãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
            var diarizedText = string.Join("\n",
                diarizedTranscriptions
                    .OrderBy(t => t.Timestamp)
                    .Select(t => {
                        string speakerName = GetDiarizedSpeakerName(t.SpeakerId);
                        return $"[{t.Timestamp:HH:mm:ss}] {speakerName}: {t.Text}";
                    }));

            // è¦ç´„ç”Ÿæˆã‚’å‘¼ã³å‡ºã—ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼‰
            await SummarizationService.SummarizeTranscriptionAsync(realtimeText, diarizedText, (partialText) => {
                summaryText = partialText;
                InvokeAsync(StateHasChanged);
            });
        }
        catch (Exception ex)
        {
            summaryError = $"è¦ç´„ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: {ex.Message}";
            Console.WriteLine($"Summarization error: {ex}");
        }
        finally
        {
            isSummarizing = false;
            StateHasChanged();
        }
    }

    private async Task CopyRealtimeTranscription()
    {
        var text = string.Join("\n", 
            realtimeTranscriptions
                .OrderBy(t => t.Timestamp)
                .Select(t => {
                    if (t.IsNote)
                    {
                        return $"[{t.Timestamp:HH:mm:ss}] ã€é€Ÿè¨˜ãƒ¡ãƒ¢ã€‘{t.Text}";
                    }
                    else
                    {
                        if (ShowRealtimeSpeaker)
                        {
                            string speakerName = GetSpeakerName(t.SpeakerId);
                            return $"[{t.Timestamp:HH:mm:ss}] {speakerName}: {t.Text}";
                        }
                        else
                        {
                            return $"[{t.Timestamp:HH:mm:ss}] {t.Text}";
                        }
                    }
                }));
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
    }

    private async Task CopyDiarizedTranscription()
    {
        var text = string.Join("\n",
            diarizedTranscriptions
                .OrderBy(t => t.Timestamp)
                .Select(t => {
                    string speakerName = GetDiarizedSpeakerName(t.SpeakerId);
                    return $"[{t.Timestamp:HH:mm:ss}] {speakerName}: {t.Text}";
                }));
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
    }

    private async Task CopySummary()
    {
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", summaryText);
    }

    public void Dispose()
    {
        SpeechService.OnTranscriptionReceived -= HandleTranscription;
        SpeechService.OnTranscribing -= HandleTranscribing;
        objRef?.Dispose();
    }

    public class TranscriptionItem
    {
        public string Text { get; set; } = string.Empty;
        public string SpeakerId { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public bool IsFinalized { get; set; } = true;
        public bool IsNote { get; set; } = false;
    }
}
