@page "/"
@using Microsoft.AspNetCore.Components.Web
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@inject SpeechRecognitionService SpeechService
@inject IJSRuntime JS

<PageTitle>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ éŸ³å£°æ–‡å­—èµ·ã“ã—</PageTitle>

<div class="container mt-4">
    <div class="row">
        <div class="col-12">
            <h1 class="mb-2">ğŸ¤ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ éŸ³å£°æ–‡å­—èµ·ã“ã—</h1>
            <p class="text-muted small mb-4">
                <i class="bi bi-info-circle"></i> ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ãƒ‡ãƒ¢ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã§ã™ã€‚éŸ³å£°èªè­˜ãŠã‚ˆã³è©±è€…åˆ†é›¢ã®çµæœã«ã¯èª¤ã‚ŠãŒå«ã¾ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
            </p>
            
            <div class="card mb-4">
                <div class="card-body">
                    <div class="d-flex align-items-center gap-3">
                        <button class="btn @(isRecording ? "btn-danger" : "btn-primary") btn-lg" 
                                @onclick="ToggleRecording"
                                disabled="@isProcessing">
                            @if (isRecording)
                            {
                                <span>â¹ åœæ­¢ã—ã¦è©±è€…åˆ†é›¢</span>
                            }
                            else
                            {
                                <span>ğŸ¤ ãƒã‚¤ã‚¯ON</span>
                            }
                        </button>
                        
                        @if (isRecording)
                        {
                            <span class="badge bg-danger fs-5">
                                <span class="spinner-grow spinner-grow-sm me-2"></span>
                                éŒ²éŸ³ä¸­
                            </span>
                        }
                        
                        @if (isProcessing)
                        {
                            <span class="badge bg-warning fs-5">
                                <span class="spinner-border spinner-border-sm me-2"></span>
                                è©±è€…åˆ†é›¢å‡¦ç†ä¸­...
                            </span>
                        }
                    </div>

                    <!-- é€Ÿè¨˜è€…ãƒ¡ãƒ¢å…¥åŠ› -->
                    @if (isRecording)
                    {
                        <div class="mb-3">
                            <div class="card border-warning">
                                <div class="card-header bg-warning bg-opacity-25">
                                    <h6 class="mb-0">ğŸ“ é€Ÿè¨˜è€…ãƒ¡ãƒ¢</h6>
                                </div>
                                <div class="card-body">
                                    <div class="mb-2">
                                        <input type="text" class="form-control" @bind="currentNote" @bind:event="oninput"
                                               @onkeydown="HandleNoteKeyDown"
                                               placeholder="ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦Enterã§è¿½åŠ ..." />
                                    </div>
                                    <button class="btn btn-sm btn-warning" @onclick="AddNote" disabled="@(string.IsNullOrWhiteSpace(currentNote))">
                                        âœï¸ ãƒ¡ãƒ¢è¿½åŠ  (Enter)
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>

            <div class="row">
                <!-- å·¦å´: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã— -->
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0">âš¡ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—</h5>
                            <small>è©±è€…åˆ†é›¢ãªã—ãƒ»é«˜é€Ÿè¡¨ç¤º</small>
                        </div>
                        <div class="card-body" style="height: 500px; overflow-y: auto;" id="realtimeArea">
                            @if (realtimeTranscriptions.Count == 0)
                            {
                                <p class="text-muted">ãƒã‚¤ã‚¯ã‚’ONã«ã—ã¦è©±ã—å§‹ã‚ã¦ãã ã•ã„...</p>
                            }
                            else
                            {
                                @foreach (var item in realtimeTranscriptions.AsEnumerable().Reverse())
                                {
                                    @if (item.IsNote)
                                    {
                                        <div class="mb-2 p-2 border border-warning bg-warning bg-opacity-10 rounded">
                                            <div class="d-flex justify-content-between align-items-start mb-1">
                                                <div>
                                                    <strong class="badge bg-warning text-dark">ğŸ“ é€Ÿè¨˜ãƒ¡ãƒ¢</strong>
                                                    <small class="text-muted ms-2">
                                                        @item.Timestamp.ToString("HH:mm:ss")
                                                    </small>
                                                </div>
                                            </div>
                                            <div class="fst-italic">@item.Text</div>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="mb-2 p-2 @(item.IsFinalized ? "bg-light" : "bg-warning bg-opacity-25") rounded">
                                            <div class="d-flex justify-content-between align-items-start mb-1">
                                                <div>
                                                    @if (item.IsFinalized && !string.IsNullOrEmpty(item.SpeakerId) && item.SpeakerId != "Unknown")
                                                    {
                                                        <strong class="@GetSpeakerColor(item.SpeakerId) me-2">
                                                            @GetSpeakerName(item.SpeakerId)
                                                        </strong>
                                                    }
                                                    <small class="text-muted">
                                                        @item.Timestamp.ToString("HH:mm:ss")
                                                        @if (!item.IsFinalized)
                                                        {
                                                            <span class="ms-2">èªè­˜ä¸­...</span>
                                                        }
                                                    </small>
                                                </div>
                                            </div>
                                            <div>@item.Text</div>
                                        </div>
                                    }
                                }
                            }
                        </div>
                    </div>
                </div>

                <!-- å³å´: è©±è€…åˆ†é›¢çµæœ -->
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-header bg-success text-white">
                            <h5 class="mb-0">ğŸ‘¥ è©±è€…åˆ†é›¢çµæœ</h5>
                            <small>åœæ­¢æ™‚ã«é«˜ç²¾åº¦åˆ†æ</small>
                        </div>
                        <div class="card-body" style="height: 500px; overflow-y: auto;" id="diarizedArea">
                            @if (diarizedTranscriptions.Count == 0)
                            {
                                <p class="text-muted">åœæ­¢ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨è©±è€…åˆ†é›¢çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™...</p>
                            }
                            else
                            {
                                @foreach (var item in diarizedTranscriptions.AsEnumerable().Reverse())
                                {
                                    <div class="mb-3 p-3 rounded @GetDiarizedSpeakerClass(item.SpeakerId)">
                                        <div class="d-flex justify-content-between align-items-start mb-2">
                                            <strong class="@GetDiarizedSpeakerColor(item.SpeakerId)">
                                                @GetDiarizedSpeakerName(item.SpeakerId)
                                            </strong>
                                            <small class="text-muted">@item.Timestamp.ToString("HH:mm:ss")</small>
                                        </div>
                                        <div>@item.Text</div>
                                    </div>
                                }
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private bool isRecording = false;
    private bool isProcessing = false;
    private List<TranscriptionItem> realtimeTranscriptions = new();
    private List<TranscriptionItem> diarizedTranscriptions = new();
    private List<TranscriptionItem> transcriptions = new(); // äº’æ›æ€§ã®ãŸã‚æ®‹ã™
    private DotNetObjectReference<Home>? objRef;
    private Dictionary<string, TranscriptionItem> ongoingTranscriptions = new();
    private string? currentRecordingPath;
    private Dictionary<string, int> speakerMapping = new(); // Azure ID â†’ UIç•ªå·ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç”¨ï¼‰
    private Dictionary<string, int> diarizedSpeakerMapping = new(); // Azure ID â†’ UIç•ªå·ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆè©±è€…åˆ†é›¢ç”¨ï¼‰
    private int nextSpeakerNumber = 1; // æ¬¡ã«å‰²ã‚Šå½“ã¦ã‚‹è©±è€…ç•ªå·
    private string currentNote = string.Empty; // ç¾åœ¨å…¥åŠ›ä¸­ã®ãƒ¡ãƒ¢

    protected override void OnInitialized()
    {
        SpeechService.OnTranscriptionReceived += HandleTranscription;
        SpeechService.OnTranscribing += HandleTranscribing;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
        }
    }

    private async Task ToggleRecording()
    {
        isRecording = !isRecording;
        
        if (isRecording)
        {
            realtimeTranscriptions.Clear();
            diarizedTranscriptions.Clear();
            speakerMapping.Clear();
            nextSpeakerNumber = 1;
            currentRecordingPath = await JS.InvokeAsync<string>("startRecording", objRef);
            await SpeechService.StartRecognitionAsync();
        }
        else
        {
            await JS.InvokeVoidAsync("stopRecording");
            await SpeechService.StopRecognitionAsync();
            
            // éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è©±è€…åˆ†é›¢ã‚’å®Ÿè¡Œ
            if (!string.IsNullOrEmpty(currentRecordingPath))
            {
                await ProcessDiarization(currentRecordingPath);
            }
        }
        
        StateHasChanged();
    }
    
    private async Task ProcessDiarization(string recordingPath)
    {
        isProcessing = true;
        StateHasChanged();
        
        try
        {
            Console.WriteLine($"Starting diarization for: {recordingPath}");
            
            // WebMãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’å–å¾—ï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã‚’ç¢ºèªï¼‰
            var downloadsPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "Downloads");
            var webmFile = Path.Combine(downloadsPath, recordingPath);
            
            if (!File.Exists(webmFile))
            {
                Console.WriteLine($"Recording file not found: {webmFile}");
                return;
            }
            
            // Azure Speeché«˜é€Ÿæ–‡å­—èµ·ã“ã—APIã§è©±è€…åˆ†é›¢ï¼ˆWebMç›´æ¥ã‚µãƒãƒ¼ãƒˆï¼‰
            var results = await SpeechService.ProcessAudioFileWithDiarizationAsync(webmFile);
            
            // è©±è€…åˆ†é›¢ç”¨ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            diarizedSpeakerMapping.Clear();
            int diarizedNextSpeakerNumber = 1;
            
            // çµæœã‚’è¡¨ç¤ºç”¨ã«å¤‰æ›
            diarizedTranscriptions.Clear();
            var baseTime = DateTime.Now;
            
            foreach (var (text, speakerId, offset) in results)
            {
                // è©±è€…åˆ†é›¢ç”¨ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½¿ç”¨
                if (!string.IsNullOrEmpty(speakerId) && speakerId != "Unknown" && !diarizedSpeakerMapping.ContainsKey(speakerId))
                {
                    diarizedSpeakerMapping[speakerId] = diarizedNextSpeakerNumber++;
                }
                
                diarizedTranscriptions.Add(new TranscriptionItem
                {
                    Text = text,
                    SpeakerId = speakerId,
                    Timestamp = baseTime.Add(offset)
                });
            }
            
            Console.WriteLine($"Diarization completed: {results.Count} segments");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Diarization error: {ex.Message}");
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task ReceiveAudioData(int[] audioData)
    {
        if (audioData != null && audioData.Length > 0)
        {
            var byteArray = new byte[audioData.Length];
            for (int i = 0; i < audioData.Length; i++)
            {
                byteArray[i] = (byte)audioData[i];
            }
            await SpeechService.ProcessAudioDataAsync(byteArray);
        }
    }

    private void HandleTranscribing(string text, string speakerId)
    {
        // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®é€”ä¸­çµŒéã‚’è¡¨ç¤ºï¼ˆè©±è€…æƒ…å ±ã¯ä½¿ã‚ãªã„ï¼‰
        // æœ€å¾Œã®æœªç¢ºå®šã‚¢ã‚¤ãƒ†ãƒ ï¼ˆãƒ¡ãƒ¢ä»¥å¤–ï¼‰ã‚’æ¢ã—ã¦æ›´æ–°
        if (realtimeTranscriptions.Count > 0)
        {
            // æœ€å¾Œã‹ã‚‰é †ã«æ¢ã—ã¦ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸæœªç¢ºå®šã®æ–‡å­—èµ·ã“ã—ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ›´æ–°
            for (int i = realtimeTranscriptions.Count - 1; i >= 0; i--)
            {
                var item = realtimeTranscriptions[i];
                if (!item.IsFinalized && !item.IsNote)
                {
                    // æ—¢å­˜ã®èªè­˜ä¸­ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä¸Šæ›¸ã
                    item.Text = text;
                    item.Timestamp = DateTime.Now;
                    InvokeAsync(StateHasChanged);
                    return;
                }
            }
        }
        
        // èªè­˜ä¸­ã®æ–°è¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
        realtimeTranscriptions.Add(new TranscriptionItem
        {
            Text = text,
            SpeakerId = "Unknown",
            Timestamp = DateTime.Now,
            IsFinalized = false
        });
        
        InvokeAsync(StateHasChanged);
    }

    private void HandleTranscription(string text, string speakerId)
    {
        // ç¢ºå®šã—ãŸçµæœã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«è¿½åŠ ï¼ˆè©±è€…æƒ…å ±ã‚‚åæ˜ ï¼‰
        if (realtimeTranscriptions.Count > 0)
        {
            // æœ€å¾Œã‹ã‚‰é †ã«æ¢ã—ã¦ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸæœªç¢ºå®šã®æ–‡å­—èµ·ã“ã—ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç¢ºå®š
            for (int i = realtimeTranscriptions.Count - 1; i >= 0; i--)
            {
                var item = realtimeTranscriptions[i];
                if (!item.IsFinalized && !item.IsNote)
                {
                    // æœ€å¾Œã®èªè­˜ä¸­ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç¢ºå®šï¼ˆè©±è€…IDã‚‚æ›´æ–°ï¼‰
                    item.Text = text;
                    item.SpeakerId = speakerId;
                    item.IsFinalized = true;
                    InvokeAsync(StateHasChanged);
                    return;
                }
            }
        }
        
        // è©²å½“ã™ã‚‹èªè­˜ä¸­ã‚¢ã‚¤ãƒ†ãƒ ãŒãªã„å ´åˆã¯æ–°è¦è¿½åŠ ï¼ˆé€šå¸¸ç™ºç”Ÿã—ãªã„ï¼‰
        realtimeTranscriptions.Add(new TranscriptionItem
        {
            Text = text,
            SpeakerId = "Unknown",
            Timestamp = DateTime.Now,
            IsFinalized = true
        });
        
        InvokeAsync(StateHasChanged);
    }

    private string GetSpeakerClass(string speakerId)
    {
        return speakerId switch
        {
            "Guest-1" => "bg-primary bg-opacity-10 border-start border-primary border-4",
            "Guest-2" => "bg-success bg-opacity-10 border-start border-success border-4",
            _ => "bg-secondary bg-opacity-10 border-start border-secondary border-4"
        };
    }

    private string GetSpeakerColor(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "badge bg-secondary";
        }
        
        // ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚ŒãŸç•ªå·ã«å¿œã˜ã¦è‰²ã‚’å¤‰ãˆã‚‹
        if (!speakerMapping.ContainsKey(speakerId))
        {
            speakerMapping[speakerId] = nextSpeakerNumber++;
        }
        
        return speakerMapping[speakerId] switch
        {
            1 => "badge bg-primary",
            2 => "badge bg-success",
            3 => "badge bg-info",
            4 => "badge bg-warning",
            5 => "badge bg-danger",
            _ => "badge bg-secondary"
        };
    }

    private async Task HandleNoteKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(currentNote))
        {
            // Enterã‚­ãƒ¼ã§ãƒ¡ãƒ¢è¿½åŠ 
            AddNote();
            await Task.CompletedTask;
        }
    }

    private void AddNote()
    {
        if (string.IsNullOrWhiteSpace(currentNote))
            return;
        
        // ãƒ¡ãƒ¢ã‚’å˜ç´”ã«è¿½åŠ ã™ã‚‹ã ã‘ã€‚èªè­˜ä¸­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯ä¸€åˆ‡è§¦ã‚Œãªã„ã€‚
        realtimeTranscriptions.Add(new TranscriptionItem
        {
            Text = currentNote.Trim(),
            Timestamp = DateTime.Now,
            IsNote = true,
            IsFinalized = true
        });
        
        currentNote = string.Empty;
        StateHasChanged();
    }

    private string GetSpeakerName(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "è­˜åˆ¥ä¸­...";
        }
        
        // Azure IDã‚’UIç”¨ã®é€£ç•ªã«ãƒãƒƒãƒ”ãƒ³ã‚°
        if (!speakerMapping.ContainsKey(speakerId))
        {
            speakerMapping[speakerId] = nextSpeakerNumber++;
        }
        
        return $"è©±è€…{speakerMapping[speakerId]}";
    }

    // è©±è€…åˆ†é›¢çµæœç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆç‹¬ç«‹ã—ãŸãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½¿ç”¨ï¼‰
    private string GetDiarizedSpeakerName(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "è­˜åˆ¥ä¸­...";
        }
        
        if (diarizedSpeakerMapping.ContainsKey(speakerId))
        {
            return $"è©±è€…{diarizedSpeakerMapping[speakerId]}";
        }
        
        return speakerId;
    }

    private string GetDiarizedSpeakerColor(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "badge bg-secondary";
        }
        
        if (diarizedSpeakerMapping.ContainsKey(speakerId))
        {
            return diarizedSpeakerMapping[speakerId] switch
            {
                1 => "badge bg-primary",
                2 => "badge bg-success",
                3 => "badge bg-info",
                4 => "badge bg-warning",
                5 => "badge bg-danger",
                _ => "badge bg-secondary"
            };
        }
        
        return "badge bg-secondary";
    }

    private string GetDiarizedSpeakerClass(string speakerId)
    {
        if (string.IsNullOrEmpty(speakerId) || speakerId == "Unknown")
        {
            return "bg-light";
        }
        
        if (diarizedSpeakerMapping.ContainsKey(speakerId))
        {
            return diarizedSpeakerMapping[speakerId] switch
            {
                1 => "bg-primary bg-opacity-10",
                2 => "bg-success bg-opacity-10",
                3 => "bg-info bg-opacity-10",
                4 => "bg-warning bg-opacity-10",
                5 => "bg-danger bg-opacity-10",
                _ => "bg-light"
            };
        }
        
        return "bg-light";
    }

    public void Dispose()
    {
        SpeechService.OnTranscriptionReceived -= HandleTranscription;
        SpeechService.OnTranscribing -= HandleTranscribing;
        objRef?.Dispose();
    }

    public class TranscriptionItem
    {
        public string Text { get; set; } = string.Empty;
        public string SpeakerId { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public bool IsFinalized { get; set; } = true;
        public bool IsNote { get; set; } = false;
    }
}
